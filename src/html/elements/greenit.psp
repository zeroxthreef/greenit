<%!
	#define POSTS_PER_PAGE 15
	string get_subgreenit_posts(string sg, string location, int page)
	{
		string final_str = "", posts_key = db_prefix + "variable:" + sg + ":posts";
		array(string) posts;
		int db_page = 0, db_end = 0, total = db->llen(posts_key);
		
		db_page = page * POSTS_PER_PAGE;
		db_end = db_page + POSTS_PER_PAGE;
		
		//write("yo " + page * POSTS_PER_PAGE + " " + total + "\n");
		
		if(db_page <= total && total)
		{
			if(db_end > total)
				db_end = total - db_page + db_page;
			
			posts = db->lrange(posts_key, db_page, db_end);
			//TODO: use location like new to sort posts
			
			
			//new only
			
			foreach(posts, string key)
				final_str += create_post_element(key);
			
			
		}
		else if(!total)
			final_str += "<h1>No posts. Feel free to create one</h1>";
		else
			final_str += "<h1>No content</h1>";
		
		
		return final_str;
	}
	
	string get_comments_post(string uri)
	{
		array(string) post = uri / "/";
		string response = "";
		
		if(sizeof(post) > 3) //make sure theres a path to a post
		{
			string key = db_prefix + "post:" + current_subgreenit(uri) + ":" + post[4];
			
			if(db->exists(key))
			{
				response = "<h1>" + db->hget(key, "title") + "</h1>";
				response += "<div class=\"post\">Posted by " + db->hget(key, "creator") + "<div class=\"post_content\">" + format_parse(db->hget(key, "body")) + "</div>" + db->hget(key, "post_date") + "</div>";
			}
			else
				response = "post does not exist";
				
		}
		else
			response = "post retrieval error";
		
		return response;
	}
	
	string get_comments(string uri)
	{
		
	}
	
	string create_post_element(string key)
	{
		array(string) temp = key / ":";
		
		//the key is corrupted for whatever reason
		string fixed_key = temp[0] +":" + temp[1] + ":" + temp[2] + ":" + replace(temp[3], "\r", "");
		
		//write("hey \"%s\"\n", fixed_key);
		
		return "\n\
		<div class=\"feed_object\">\n\
			<div class=\"feed_object_updn_container\">(" + db->hget(key, "upvotes") + ") upvote<br>(" + db->hget(key, "downvotes")  + ") downvote</div><div class=\"feed_object_title_container\"><a href=\"" + "/g/" + db->hget(fixed_key, "parent") + "/comments/" + temp[3] + "\">" + db->hget(fixed_key, "title") + "</a></div>\n\
		</div>";
	}
	
	string unformat_title(string title)
	{
		array(string) temp = title / "_";
		
		return temp * " ";
	}
	
	string generate_nav(string uri)
	{
		array(string) sub_uri = trim_uri(uri) / "/";
		int page = 0, other = 0, abort = 0;
		string sub_path = "";
		
		if(uri == "/")
		{
			string base = "/g/all/p";
			
			string prev = base + (page - 1) + "/";
			string next = base + (page + 1) + "/";
			
			return "<br><center><a href=\"" + prev + "\" >&ltprevious|</a>" + page + "<a href=\"" + next + "\" >|next&gt</a></center><br>";
		}
		
		if(!subgreenit_exists(uri))
		{
			return "<br><center>no pages</center><br>";
		}
		
		
		
		if(sizeof(sub_uri) > 2)
			sub_path += sub_uri[3];
		
		if(sizeof(sub_path))
		{
			if(sub_path[0] == 'p' && sub_path[1] != 'o') //its the home page
			{
				string temp = sub_path[1..];
				page = (int)temp;
			}
			else if(sub_path == "comments")
				abort = 1;
			else //its any other
			{
				if(sub_uri[4])
				{
					other++;
					string temp = sub_uri[4][1..];
					page = (int)temp;
				}
			}
		}
		
		if(abort)
			return "";
		
		//spit out a navigation string
		string base = "/g/" + sub_uri[2] + "/";
		
		if(other)
			base += sub_uri[3] + "/p";
		else
			base += "p";
		
		string prev = base + (page - 1) + "/";
		string next = base + (page + 1) + "/";
		
		
		
		return "<br><center><a href=\"" + prev + "\" >&ltprevious|</a>" + page + "<a href=\"" + next + "\" >|next&gt</a></center><br>";
	}
	
	
	string current_subgreenit(string query)
	{
		if(query == "/")
			return "all";
		else if(query[..strlen("/g")] != "/g/")
			return "";
		
		if(query != "/")
		{
			string temp_str = query[strlen("/g/")..], final_str = "";
			
			if(search(temp_str, "/") != 0)
			{
				//write("hey %s\n", temp_str);
				for(int i = 0; i < strlen(temp_str); i++)
				{
					if(temp_str[i] != '/')
						final_str += temp_str[i..i+0];
					else
						return final_str;
				}
			}
			else
				return temp_str;
			
		}
		
		return "";
	}
	
	string banner_current_subgreenit(string query)
	{
		if(query && strlen(current_subgreenit(query)))
			return "g/" + current_subgreenit(query);
		
		return "";
	}
	
	int in_subgreenit(string query)
	{
		return db->exists(db_prefix + "subgreenit:" + current_subgreenit(query));
	}
	
	string get_create_form(string subgreenit)
	{
		string form = "\n\
		<form action=\"/g/" + subgreenit + "/create/\" method=\"post\">\n\
			Title:<br>\n\
			<input type=\"text\" name=\"title\"><br>\n\
			Body:<br>\n\
			<textarea name=\"body\" cols=\"80\" rows=\"20\"></textarea><br><br>\n\
			<input type=\"submit\" value=\"submit\" id=\"submit\">\n\
		</form>";
		
		return form;
	}
	
	int is_clean_title_string(string title)
	{
		if(strlen(title) > 50 || strlen(title) < 2)
			return 0;
		
		for(int i = 0; i < strlen(title); i++)//make sure only alpha
		{
			if((title[i] < 32 || title[i] > 126 || title[i] == 95))
				return 0;
		}
		
		return 1;
	}
	
	int subgreenit_exists(string uri)
	{
		string key = db_prefix + "subgreenit:" + current_subgreenit(uri);
		
		return db->exists(key);
	}
	
	string safe_title_string(string title)
	{
		string final_str;
		array(string) temp;
		
		temp = title / " ";
		
		final_str = temp * "_";
		
		temp = final_str / "<";
		
		final_str = temp * "&lt";
		
		temp = final_str / ">";
		
		final_str = temp * "&gt";
		
		return final_str;
	}
	
	string safe_about_string(string about)
	{
		string final_str;
		array(string) temp;
		
		temp = about / "<";
		
		final_str = temp * "&lt";
		
		temp = final_str / ">";
		
		final_str = temp * "&gt";
		
		temp = final_str / "\n";
		
		final_str = temp * "<br>";
		
		return final_str;
	}
	
	string format_parse(string input)
	{
		string final_str = input;
		array(string) temp;
		int img_esc = 0, video_esc = 0, url_esc = 0, bold_esc = 0, ital_esc = 0, under_esc = 0;
		
		
		
		//strip out html
		
		temp = final_str / "<";
		
		final_str = temp * "&lt";
		
		temp = final_str / ">";
		
		final_str = temp * "&gt";
		
		//control formats
		
		//imgur images
		
		array(string) img_open = final_str / "[img]";
		array(string) img_close = final_str / "[/img]";
		
		if(sizeof(img_open) == sizeof(img_close))
		{
			final_str = img_open * "<img style=\"\width: 100%;\" src=\"https://i.imgur.com/";
			array(string) img_close2 = final_str / "[/img]";
			final_str = img_close2 * "\"/>";
		}
		
		//youtube videos
		
		array(string) vid_open = final_str / "[video]";
		array(string) vid_close = final_str / "[/video]";
		
		if(sizeof(vid_open) == sizeof(vid_close))
		{
			final_str = vid_open * "<iframe style=\"\width: 94%; height: 400px;\" src=\"https://www.youtube.com/embed/";
			array(string) vid_close2 = final_str / "[/video]";
			final_str = vid_close2 * "\"></iframe>";
		}
		
		//links
		
		array(string) url_open = final_str / "[url]";
		array(string) url_close = final_str / "[/url]";
		
		if(sizeof(url_open) == sizeof(url_close))
		{
			final_str = url_open * "<a href=\"";
			array(string) vid_close2 = final_str / "[/url]";
			final_str = vid_close2 * "\">link</a>";
		}
		
		//bold
		
		array(string) bold_open = final_str / "[b]";
		array(string) bold_close = final_str / "[/b]";
		
		if(sizeof(bold_open) == sizeof(bold_close))
		{
			final_str = bold_open * "<b>";
			array(string) bold_close2 = final_str / "[/b]";
			final_str = bold_close2 * "</b>";
		}
		
		//italics
		
		array(string) italics_open = final_str / "[i]";
		array(string) italics_close = final_str / "[/i]";
		
		if(sizeof(italics_open) == sizeof(italics_close))
		{
			final_str = italics_open * "<i>";
			array(string) italics_close2 = final_str / "[/i]";
			final_str = italics_close2 * "</i>";
		}
		
		//underline
		
		array(string) under_open = final_str / "[u]";
		array(string) under_close = final_str / "[/u]";
		
		if(sizeof(under_open) == sizeof(under_close))
		{
			final_str = under_open * "<u>";
			array(string) under_close2 = final_str / "[/u]";
			final_str = under_close2 * "</u>";
		}
		
		
		
		
		//finally, modify all newlines
		temp = final_str / "\n";
		
		final_str = temp * "<br>";
		
		return final_str;
	}
	
%>